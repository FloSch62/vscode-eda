/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
    "/core/about/activity": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the cluster activity status.
         * @description Unless an error is encountered, it simply returns an "NoContent" (for active)
         *     or "ServiceUnavailable" (for standby) status. In other words, there is no
         *     response body for these cases.
         */
        get: operations["activityGet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/about/health": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Returns an indication of the health of the EDA cluster. HTTP status OK
         *     indicates that all is good.  HTTP status ServiceUnavailable indicates that
         *     all of the services of the EDA cluster (other than the API service) are down.
         *     HTTP status InternalServerError indicates that one service is down, but at
         *     least one service (other than the API service) is up. */
        get: operations["healthGet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/about/version": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns version information for the EDA cluster. */
        get: operations["versionGet"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/access/v1/namespaces": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the list of namespaces the current user can access. If the current user is able to access the
         *     'All Namespaces' option that will be indicated in the response. */
        get: operations["accessGetNamespaces"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/federationproviders": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the user federation providers configured in EDA.
         * @description Returns a list of federation providers, possibly filtered based on the "name" query parameter.
         */
        get: operations["adminGetProviders"];
        put?: never;
        /**
         * Create an EDA user federation provider.
         * @description Creates an EDA user federation provider using the definition in the body.  The UUID cannot be set, it is
         *     created by the system when the provider is created.
         */
        post: operations["adminCreateProvider"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/federationproviders/{uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get the EDA user federation provider specified by the uuid in the request URL.
         * @description Returns the definition of the specified EDA federation provider.
         */
        get: operations["adminGetProvider"];
        /**
         * Update an EDA user federation provider.
         * @description Replaces the definition of an EDA user federation provider with the definition in the body.
         *     The UUID cannot be changed.
         */
        put: operations["adminUpdateProvider"];
        post?: never;
        /**
         * Delete an EDA user federation provider.
         * @description Deletes the EDA user federation provider specified by the UUID in the path.
         */
        delete: operations["adminDeleteProvider"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/federationprovidertest": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /**
         * Test connection and authentication for an EDA federation provider.
         * @description This endpoint instructs the keycloak server to test a federation provider
         *     on behalf of the requesting user.
         */
        post: operations["adminTestProvider"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns all EDA user-groups.
         * @description Returns the list of defined EDA user-groups.  Query parameters control if
         *     the associated users and roles are returned by name only, or if the full definition
         *     is returned.
         */
        get: operations["adminGetUserGroups"];
        put?: never;
        /**
         * Creates a new EDA user group.
         * @description Creates a new EDA user group using the definition in the request body. The
         *     EDA roles for the new group can be included in the definition, but the users
         *     belonging to the group cannot be specified here.  The users of the group
         *     must be modified via either the "groups of user" membership APIs, or the
         *     "users of group" membership APIs.  Same for the roles.  A uuid definition in
         *     the body will be ignored; the uuid of the group is assigned by the system
         *     when it is created.
         */
        post: operations["adminCreateUserGroup"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/groups/{uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns a single EDA user-group.
         * @description Returns the single EDA user-group identified by the uuid parameter.  Query parameters control if
         *     the associated users and roles are returned by name only, or if the full definition
         *     is returned.
         */
        get: operations["adminGetUserGroup"];
        /**
         * Updates an EDA user group
         * @description Update the definition of the EDA user group specified by the UUID in the
         *     path. The name and UUID of the group cannot be modified in this manner.  The
         *     roles of the user group will be set to the set of roles in the new
         *     definition.  The users of a user group cannot be modified via this mechanism,
         *     but must be modified via the "groups of user" or "users of group" APIs.
         *     A similar restriction applies to the roles of the user group.
         */
        put: operations["adminUpdateUserGroup"];
        post?: never;
        /**
         * Deletes an EDA user group.
         * @description Deletes the EDA user group identified by the UUID in the path.  Any user which is
         *     currently a member of the group will no longer be a member of the group after this.
         */
        delete: operations["adminDeleteUserGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/groups/{uuid}/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Returns the roles assigned to an EDA user-group.
         * @description Returns a list of role definitions for the roles assigned to the specified EDA user group.
         */
        get: operations["adminGetRolesOfUserGroup"];
        /**
         * Replace the roles of an EDA user group.
         * @description Replaces the roles of the specified user group with the roles in the body.  This will affect
         *     the roles of any users assigned to the user group.
         */
        put: operations["adminSetRolesOfUserGroup"];
        /**
         * Assign roles to an EDA user group.
         * @description Assigns the specified set of roles to the specified user group (as well as the ones that
         *     were previously assigned to the user group). This means that all the users assigned
         *     to that user group will now have that set of roles, in addition to any roles they already had.
         */
        post: operations["adminAddRolesToUserGroup"];
        /**
         * Remove roles from an EDA user group.
         * @description Removes the roles specified in the body from the user group specified in the path.
         *     This will affect the roles of any users assigned to the user group.
         */
        delete: operations["adminRemoveRolesFromUserGroup"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/namespaces/{namespace}/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream the EDA roles in the specified namespace.
         * @description Either returns or streams the EDA role definitions, depending on query
         *     parameters.
         */
        get: operations["adminGetRoles"];
        put?: never;
        /**
         * Create an EDA namespaced role in the specified namespace.
         * @description Creates a new EDA role using the definition in the request body.
         */
        post: operations["adminCreateRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/namespaces/{namespace}/roles/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream a single namespaced EDA role.
         * @description Returns the specifed namespaced EDA role definition, or streams the EDA role and any changes,
         *     depending on the streaming query parameters.
         */
        get: operations["adminGetRole"];
        /**
         * Update an EDA namespaced role with new content.
         * @description Replaces the definition of the specifed EDA role with the definition in the body.
         *     The role name cannot be modified.
         */
        put: operations["adminUpdateRole"];
        post?: never;
        /**
         * Delete an EDA namespaced role.
         * @description Deletes the specified EDA role. This will fail if the role is assigned to any user groups.
         *     You must remove the role from the user groups first.
         */
        delete: operations["adminDeleteRole"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/passwordpolicy": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the current EDA password policy parameters.
         * @description Returns the parameters for the currently configured EDA password policy.
         *     If a "get-default=true" query parameter is passed, the default password policy definition
         *     is returned.
         */
        get: operations["adminGetPasswordPolicy"];
        /** Sets the EDA password policy parameters. */
        put: operations["adminUpdatePasswordPolicy"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/roles": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream the EDA cluster roles.
         * @description Either returns or streams the EDA cluster role definitions, depending on query
         *     parameters.
         */
        get: operations["adminGetClusterRoles"];
        put?: never;
        /**
         * Create an EDA cluster role.
         * @description Creates a new EDA cluster role using the definition in the request body.
         */
        post: operations["adminCreateClusterRole"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/roles/{name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Get/stream a single EDA cluster role.
         * @description Returns the specifed EDA cluster role definition, or streams the EDA role and any changes,
         *     depending on the streaming query parameters.
         */
        get: operations["adminGetClusterRole"];
        /**
         * Update an EDA cluster role with new content.
         * @description Replaces the definition of the specifed EDA role with the definition in the body.
         *     The role name cannot be modified.
         */
        put: operations["adminUpdateClusterRole"];
        post?: never;
        /**
         * Delete an EDA cluster role.
         * @description Deletes the specified EDA role. This will fail if the role is assigned to any user groups.
         *     You must remove the role from the user groups first.
         */
        delete: operations["adminDeleteClusterRole"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Returns EDA users, either all users, or user(s) filtered on username
         *     or email address, based on query parameters. */
        get: operations["adminGetUsers"];
        put?: never;
        /**
         * Creates an EDA user with the JSON information in the request body.
         * @description Note that group membership is not changed (the "groups" data in the user
         *     definition is ignored).  The groups of a user must be modified via the
         *     core/admin/users/{uuid}/groups REST endpoint or by modifying the group definitions
         *     using group REST endpoints.
         */
        post: operations["adminCreateUser"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Returns a single EDA user specified by the userid (UUID) parameter in the path. */
        get: operations["adminGetUser"];
        /**
         * Replaces the attributes of an EDA user with the JSON information in the request body.
         * @description Note that the userid/UUID and name cannot be modified.
         *     Note also that group membership is not changed (the "groups" data in the user
         *     definition is ignored).  The groups of a user must be modified via the
         *     core/admin/users/{uuid}/groups REST endpoint or by modifying the group definitions
         *     using group REST endpoints.
         */
        put: operations["adminModifyUser"];
        post?: never;
        /** Deletes the user identified by userid/UUID in the request path. */
        delete: operations["adminDeleteUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}/actionemails": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Invokes the specified email action for the specified user. */
        put: operations["adminExecuteEmailActions"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}/groups": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** @description Replaces the group memberships of the specified user to that they are members of only the
         *     groups specified by the group UUIDs in the request body. */
        put: operations["adminSetGroupsOfUser"];
        /** Adds the specified user to the groups specified by the group UUIDs in the request body. */
        post: operations["adminAddGroupsToUser"];
        /** Removes the specified user from the groups specified by the group UUIDs in the request body. */
        delete: operations["adminRemoveGroupsFromUser"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/admin/users/{uuid}/resetpassword": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        /** Sets/updates/replaces the password of the specified user. */
        put: operations["adminSetUserPassword"];
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/alarms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets all alarms including namespaced alarms from all namespaces and all non-namespaced
         *     alarms.  This API can get a snapshot of the alarms, or can return a
         *     stream of the alarms and the changes to them. The API does not provide
         *     suppressed alarms by default, but the suppressed alarms will be included if
         *     the "all" query parameter is set to "true". */
        get: operations["alarmGetAlarms"];
        /** @description Performs the specified acknowledgement action provided in the "action" query
         *     on the alarms named in the JSON string array in the body.  The action
         *     can be performed on alarms across multiple namespaces, including non-namespaced
         *     alarms.  It is possible for some actions on alarms to have been successful and
         *     other actions to have failed if an error is returned. */
        put: operations["alarmPutAlarms"];
        post?: never;
        /** @description Deletes all the alarms named in the JSON string array in the body.  Deletes
         *     can be performed on alarms across multiple namespaces, including non-namespaced
         *     alarms.  It is possible for some deletes on alarms to have been successful and
         *     other deletes to have failed if an error is returned. */
        delete: operations["alarmDeleteAlarms"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/alarms/{alarm-name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets a single non-namespaced alarm, as specified by the alarm-name parameter.
         * @description This API can get a snapshot of the alarm, or a stream of changes to that alarm.
         *     The suppression state of the alarm is irrelevant.
         */
        get: operations["alarmGetAlarm"];
        /** @description Performs the specified acknowledgement action provided in the "action" query
         *     on the non-namespaced alarm with the specified name (alarm-name). */
        put: operations["alarmPutAlarm"];
        post?: never;
        /** @description Deletes the non-namespaced alarm with the specified name (alarm-name).  If the alarm is not
         *     cleared, the alarm will not be deleted, but there will be no error. */
        delete: operations["alarmDeleteAlarm"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/alarms/{alarm-name}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the history of the specified non-namespaced alarm.  This API supports streaming,
         * @description and if requested the history of the alarm will be streamed back on the provided stream,
         *     including any subsequent changes.  If not using streaming, a snapshot of the history
         *     will be returned.
         */
        get: operations["alarmGetAlarmHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/namespaces/{nsName}/alarm/{alarm-name}/history": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the history of the specified alarm in a namespace.  This API supports streaming,
         * @description and if requested the history of the alarm will be streamed back on the provided stream,
         *     including any subsequent changes.  If not using streaming, a snapshot of the history
         *     will be returned.
         */
        get: operations["alarmGetNamespaceAlarmHistory"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/namespaces/{nsName}/alarms": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets all alarms from a specific namespace.  This API can get a snapshot of the
         *     alarms, or can return a stream of the alarms and the changes to them. The API does
         *     not provide suppressed alarms by default, but the suppressed alarms will be included if
         *     the "all" query parameter is set to "true". */
        get: operations["alarmGetNamespaceAlarms"];
        /** @description Performs the specified acknowledgement action provided in the "action" query
         *     on the alarms named in the JSON string array in the body.  All alarms acted on must be
         *     within a single namespace.  It is possible for some actions on alarms to have been
         *     successful and other actions to have failed if an error is returned. */
        put: operations["alarmPutNamespaceAlarms"];
        post?: never;
        /** @description Deletes all the alarms named in the JSON string array in the body.  All alarms acted
         *     on must be within a single namespace.  It is possible for some deletes on alarms to have
         *     been successful and other deletes to have failed if an error is returned. */
        delete: operations["alarmDeleteNamespaceAlarms"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alarm/v2/namespaces/{nsName}/alarms/{alarm-name}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets a single namespaced alarm, as specified by the nsName and alarm-name parameters.
         * @description This API can get a snapshot of the alarm, or a stream of changes to that alarm.
         *     The suppression state of the alarm is irrelevant.
         */
        get: operations["alarmGetNamespaceAlarm"];
        /** @description Performs the specified acknowledgement action provided in the "action" query
         *     on the namespaced alarm with the specified name (alarm-name). */
        put: operations["alarmPutNamespaceAlarm"];
        post?: never;
        /** @description Deletes the namespaced alarm with the specified name (alarm-name).  If the alarm is not
         *     cleared, the alarm will not be deleted, but there will be no error. */
        delete: operations["alarmDeleteNamespaceAlarm"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alltransaction/v1/details/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the details of a posted transaction for any user. */
        get: operations["transGetAllDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alltransaction/v1/diffs/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the diff view of the configuration records in a posted transaction for any user, or the diff view of a node configuration. */
        get: operations["transGetAllDiffs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alltransaction/v1/resultsummary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets summarized results of transactions for all users.  These results can be streamed back to the requestor if
         *     the appropriate streaming parameters are supplied. */
        get: operations["transGetAllSummaryResult"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/alltransaction/v1/state/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the state of a posted transaction ignoring the user that intiated the transaction.  State changes for the transaction
         *     can be streamed back to the requestor if the appropriate streaming parameters are supplied. */
        get: operations["transGetAllState"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/autocomplete/v1/labels": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Gets a list of suggested key/values for labels. */
        post: operations["toolsGetLabelCompletions"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/nodeconfig/v2/namespaces/{nsName}/nodes/{nodeName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the node config of a node. */
        get: operations["toolsGetNodeConfig"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initiate a streaming query request using the EDA query language.
         * @description Streaming is mandatory for this API.
         *     Whenever the information described by the query parameter changes,
         *     the result of the query will be sent to the requestor/client via the specified stream.
         *     Note that if the namespaces argument is not provided, the user must have cluster role
         *     permission to access the table specified in the query.  If one or more namespaces
         *     are supplied, the user must have cluster role permission, or role permission (in all
         *     the specified namespaces) to access the table specified in the query.
         */
        get: operations["queryGetQuery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1/eql": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initiate a streaming query request using the EDA query language.
         * @description Streaming is mandatory for this API.
         *     Whenever the information described by the query parameter changes,
         *     the result of the query will be sent to the requestor/client via the specified stream.
         */
        get: operations["queryGetEqlQuery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1/eql/autocomplete": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Request auto-completion for the specified EDA query-language string.
         * @description Returns auto-completion information for the given (incomplete) EQA query language query.
         *     The number of results returned can be limited with an optional parameter.
         */
        get: operations["queryGetEqlQueryAutoComplete"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/query/v1/nql": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Initiate a streaming query request using the 'natural' query language.
         * @description Streaming is mandatory for this API.
         *     Whenever the information described by the query parameter changes,
         *     the result of the query will be sent to the requestor/client via the specified stream.
         *     Note that if the namespaces argument is not provided, the user must have cluster role
         *     permission to access the table specified in the query.  If one or more namespaces
         *     are supplied, the user must have cluster role permission, or role permission (in all
         *     the specified namespaces) to access the table specified in the query.
         */
        get: operations["queryGetNqlQuery"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description list topologies that have been published in the database */
        get: operations["topologies"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description get the metadata for a specific topology */
        get: operations["topology"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/overlay": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description list overlays for a specific topology */
        get: operations["overlays"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/overlay/{overlayName}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description get the metadata for a specific overlay */
        get: operations["overlay"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/topology/v1/{topologyName}/state": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** @description get the state of a specific topology with option to specify the namespace, groupings and overlays */
        post: operations["topologyPostState"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Runs a transaction. */
        post: operations["transPostTransactionV1"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v1/details/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the details of a posted transaction for a user. */
        get: operations["transGetDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v1/diffs/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the diff view of the configuration records in a posted transaction for the user, or the diff view of a node configuration. */
        get: operations["transGetDiffs"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v1/restore/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Restores the configuration of the system to the state at the time of the transaction identified by the specified transaction id. */
        post: operations["transRestoreTransactionV1"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v1/resultsummary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets summarized results of transactions run by the user.  These results can be streamed back to the requestor if
         *     the appropriate streaming parameters are supplied. */
        get: operations["transGetSummaryResultV1"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v1/revert/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reverts the transaction identified by the transaction id. */
        post: operations["transRevertTransactionV1"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v1/state/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the state of a posted transaction.  State changes for the transaction can be streamed back to the
         *     requestor if the appropriate streaming parameters are supplied. */
        get: operations["transGetStateForUser"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Runs a transaction. */
        post: operations["transPostTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/restore/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Restores the configuration of the system to the state at the time of the transaction identified by the specified transaction id. */
        post: operations["transRestoreTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/diffs/nodecfg/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Get the diff view of a node configuration change from a transaction. */
        get: operations["transGetNodeConfigDiff"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/diffs/resource/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the diff view of a resource change from a posted transaction. */
        get: operations["transGetResourceDiff"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/execution/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the details of a posted transaction.  This does not include the input resources, which can be retrieved using the transGetResultInputResources operation. */
        get: operations["transGetResultExecution"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/inputresources/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /**
         * Gets the input resources of a posted transaction.  This list is filtered by the access rights of the requesting user.
         * @description If the user does not have read access to any resources, these resources will not be included in the list, and in this
         *     case the the limitedAccess field in the response will be set to true.
         */
        get: operations["transGetResultInputResources"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/summary": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets summarized results of transactions for all users.  These results can be streamed back to the requestor if
         *     the appropriate streaming parameters are supplied. */
        get: operations["transGetSummaryResultList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/result/summary/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets summarized results of a single transaction. */
        get: operations["transGetSummaryResult"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/revert/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Reverts the transaction identified by the transaction id. */
        post: operations["transRevertTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/state/{transactionId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the state of a posted transaction.  State changes for the transaction
         *     can be streamed back to the requestor if the appropriate streaming parameters are supplied. */
        get: operations["transGetState"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/transaction/v2/validate": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Validates a list of CRs to check that they are properly formed before later adding them to a transaction. */
        post: operations["transValidateTransaction"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/directory": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description gets the content of a user-storage directory */
        get: operations["ussGetDirectory"];
        put?: never;
        post?: never;
        /** @description delete a user-storage directory (and its contents) */
        delete: operations["ussDeleteDirectory"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns the content of a single user-storage file */
        get: operations["ussGetFile"];
        /** @description Creates a user-storage file */
        put: operations["ussPutFile"];
        /** @description Creates/writes the content of a user-storage file */
        post: operations["ussPostFile"];
        /** @description deletes a user-storage file */
        delete: operations["ussDeleteFile"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Deletes a number of user-storage files as specified in the JSON body of the request.
         * @description Deletes the user-storage files whose paths are in the JSON string array in the body
         *     of the request.  There is never partial success.  Either all the deletes succeed,
         *     or none of them occur.  i.e. if an error response comes back, no files were
         *     deleted.
         */
        delete: operations["ussDeleteFiles"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/shared/directory": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description gets the content of a user-storage directory from the shared region */
        get: operations["ussGetSharedDirectory"];
        put?: never;
        post?: never;
        /** @description delete a user-storage directory (and its contents) from the shared region */
        delete: operations["ussDeleteSharedDirectory"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/shared/file": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description returns the content of a single user-storage file from the shared region */
        get: operations["ussGetSharedFile"];
        /** @description Creates a user-storage file to the shared region */
        put: operations["ussPutSharedFile"];
        /** @description Creates/writes the content of a user-storage file to the shared region */
        post: operations["ussPostSharedFile"];
        /** @description deletes a user-storage file from the shared region */
        delete: operations["ussDeleteSharedFile"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/user-storage/v2/shared/files": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        post?: never;
        /**
         * Deletes a number of user-storage files from the shared region as specified in the JSON
         *     body of the request.
         * @description Deletes the user-storage files whose paths are in the JSON string array in the body
         *     of the request.  There is never partial success.  Either all the deletes succeed,
         *     or none of them occur.  i.e. if an error response comes back, no files were
         *     deleted.
         */
        delete: operations["ussDeleteSharedFiles"];
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/workflow/v1": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        get?: never;
        put?: never;
        /** Runs a workflow. */
        post: operations["workflowPostWorkflow"];
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/workflow/v1/{nsName}/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the list of posted workflows in the specified namespace. */
        get: operations["getNamespaceWorkflowList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/workflow/v1/details/{workflowId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the detailed results of a posted workflow. */
        get: operations["workflowGetDetails"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/workflow/v1/list": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the list of posted workflows for all namespaces. */
        get: operations["getWorkflowList"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/workflow/v1/state/{workflowId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Gets the state of a posted workflow.  State changes for the workflow can be streamed back to the
         *     requestor if the appropriate streaming parameters are supplied. */
        get: operations["workflowGetState"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
    "/core/workflow/v1/workflow/{workflowId}": {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** Gets the details of the workflow. */
        get: operations["getWorkflow"];
        put?: never;
        post?: never;
        delete?: never;
        options?: never;
        head?: never;
        patch?: never;
        trace?: never;
    };
}
export type webhooks = Record<string, never>;
export interface components {
    schemas: {
        /** @description The information about a single alarm or alarm history */
        AlarmData: {
            /** @description An indication if the alarm has been acknowledged. */
            acknowledged?: boolean;
            /** @description Indicates the end time of the acknowledgement. */
            acknowledgedUntil?: string;
            /** @description An indication if the alarm has been cleared. */
            cleared?: boolean;
            /** @description The cluster member that generated this alarm. */
            clusterMember?: string;
            /** @description A description for the alarm. */
            description?: string;
            /** @description Indicates the group of the resource the alarm is present on. */
            group?: string;
            /** @description a unnormalized jspath relating to the object in the alarm state. For
             *     example
             *     .node{.name=="spine-1-1"}.srl{.version=="24.10.1"}.interface{.name=="ethernet-1-1"}. */
            jsPath?: string;
            /** @description Indicates the kind of resource the alarm is present on. */
            kind?: string;
            /** @description the time this alarm was last acknowledged. */
            lastAcknowledged?: string;
            /** @description The last time that the alarm was changed; as provided by the raiser of the alarm. */
            lastChanged?: string;
            /** @description the time this alarm was last suppressed. */
            lastSuppressed?: string;
            /** @description The unique name for the alarm, e.g. InterfaceDown-spine-1-1-ethernet-1-1. */
            name?: string;
            /** @description The namespace of the alarm */
            namespace?: string;
            /**
             * Format: int64
             * @description The number of occurrences of this alarm (the number of times it has been raised).
             */
            occurrences?: number;
            /** @description The names of other alarms that is are parents of this alarm. This is used to
             *     filter out alarms that are not a root cause. */
            parentAlarms?: string[];
            /** @description the probable cause for raising the alarm. This field is optional, and
             *     should also be a description indicating the primary probable cause of the
             *     alarm, which may be enriched with relevant information from this specific
             *     alarm instance. The complete alarm below contains an example. */
            probableCause?: string;
            /** @description any remedial actions the user could try to resolve/clear the alarm. This
             *     field is optional, and may also be enriched with relevant information
             *     from this specific alarm instance. The complete alarm below contains an
             *     example. */
            remedialAction?: string;
            /** @description The name of the resource that this alarm is present on. */
            resource?: string;
            /**
             * @description Severity of the alarm
             * @enum {string}
             */
            severity?: "warning" | "minor" | "major" | "critical";
            /** @description Indicates indicates the group of the resource that raised this alarm, e.g. interfaces.eda.nokia.com. */
            sourceGroup?: string;
            /** @description Indicates the Kind of the resource that raised this alarm, e.g. InterfaceState. */
            sourceKind?: string;
            /** @description Indicates the the name of the resource that raised this alarm, e.g. spine-1-1-ethernet-1-1. */
            sourceResource?: string;
            /** @description An indication if the alarm has been suppressed. */
            suppressed?: boolean;
            /** @description Indicates the end time of the suppression. */
            suppressedUntil?: string;
            /** @description A kind for the alarm, e.g. InterfaceDown */
            type?: string;
        };
        AlarmHistoryData: {
            alarm?: components["schemas"]["AlarmData"];
            /** @description The index of the history entry within the entries for a single alarm.. */
            index?: string;
        };
        AlarmNamespaceAndName: {
            /** @description The name of an alarm */
            name?: string;
            /** @description The namespace of an alarm */
            namespace?: string;
        };
        AuthPasswordPolicy: {
            /** @description If true, prevents passwords from being or containing the user name. */
            allowUserName?: boolean;
            /**
             * Format: int64
             * @description Minimum number of digits required in a password. Can be zero.
             */
            digits?: number;
            /**
             * Format: int64
             * @description The maximum number of days until a password change is enforced.
             *     A value of zero means no change is required.
             */
            forceExpiredPasswordChange?: number;
            /**
             * @description The hashing algorithm to use when hashing stored passwords.
             * @enum {string}
             */
            hashingAlgorithm?: "argon2" | "pbkdf2-sha512" | "pbkdf2-sha256" | "pbkdf2";
            /**
             * Format: int64
             * @description Minimum password length.  This must be at least 1.
             */
            length?: number;
            /**
             * Format: int64
             * @description Minimum number of lower case characters required in a password. Can be zero.
             */
            lowerCase?: number;
            /**
             * Format: int64
             * @description The number of seconds before the users access will be restored, after too many authentication failures.
             */
            maxFailureWaitSeconds?: number;
            /**
             * Format: int64
             * @description The number of login/authentication failures before a lockout policy takes effect. Zero means no enforcement.
             */
            maxLoginFailure?: number;
            /**
             * Format: int64
             * @description The number of passwords remembered to enforce no re-use of passwords. Zero means no re-use enforcement.
             */
            passwordHistory?: number;
            /** @description If true, lockout is permanent and the users access must be re-enabled by an administrator.
             *     If false, the users access will be re-enabled after "maxFailureWaitSeconds" seconds. */
            permanentLockout?: boolean;
            /**
             * Format: int64
             * @description When lockout is not permanent, the count of authentication failures for a user will be reset
             *     this many seconds after the last authentication failure.
             */
            resetTimeSeconds?: number;
            /**
             * Format: int64
             * @description Minimum number of special characters required in a password. Can be zero.
             */
            specialChars?: number;
            /**
             * Format: int64
             * @description Minimum number of upper case characters required in a password. Can be zero.
             */
            upperCase?: number;
        };
        AuthProvider: {
            auth?: components["schemas"]["AuthProvider_auth"];
            /** @description If true, checking/syncing this LDAP provider is enabled. */
            enabled?: boolean;
            groupSupport?: components["schemas"]["AuthProvider_groupSupport"];
            /** @description Name of the LDAP attribute, which is used as a unique object identifier (UUID) for objects in LDAP. */
            idAttribute: string;
            /** @description If true, the LDAP information will be imported into the EDA (Keycloak) database. */
            import?: boolean;
            /** @description The name to give to the LDAP provider; must be unique. */
            name: string;
            /** @description Set to true if the LDAP server supports pagination. */
            pagination?: boolean;
            /** @description If true, periodic synchronization of new changed or newly created LDAP users to Keycloak will occur. */
            periodicSync?: boolean;
            /**
             * Format: int64
             * @description If periodic sync is enabled, this is the period in seconds that synchronization will occur.
             */
            periodicSyncSecs?: number;
            /** @description Name of the LDAP attribute, which is used as RDN (top attribute) of typical user DN. Usually it's the same as the Username LDAP attribute, however it is not required. */
            rdnLDAPAttribute: string;
            /**
             * @description If false, changes made to LDAP-mapped attribute via EDA will be synced back to the LDAP server.  Otherwise, changes are not made in LDAP.
             * @default true
             */
            readonly readOnly: boolean;
            /**
             * @description Must be "One Level" or "Subtree".  If "One Level", the search applies only for users in the DNs specified by User DNs. If "Subtree", the search applies to the whole subtree.
             * @enum {string}
             */
            scope?: "One Level" | "Subtree";
            /**
             * Format: int64
             * @description LDAP connection timeout in milliseconds
             */
            timeout?: number;
            /** @description If true, encrypts the connection to LDAP using STARTTLS */
            tls?: boolean;
            /**
             * @description The type of provider.  Currently only "ldap" is supported.
             * @enum {string}
             */
            type: "ldap";
            /** @description Connection URL to your LDAP server */
            url: string;
            /** @description Full DN of LDAP tree where your users are. This DN is the parent of LDAP users. */
            userDN: string;
            /** @description All values of LDAP objectClass attribute for users in LDAP, divided by commas. (e.g. inetOrgPerson, organizationalPerson). */
            userObjectClasses: string;
            /** @description Additional LDAP filter for filtering searched users. Leave this empty if you don't need an additional filter. Make sure that it starts with '(' and ends with ')'. */
            userSearchFilter?: string;
            /** @description Name of the LDAP attribute, which is mapped as EDA username. For many LDAP server vendors it can be 'uid'. */
            usernameAttribute: string;
            /** @description The unique identifier given to the entry when it is created. */
            uuid?: string;
            /** @description LDAP vendor (provider). */
            vendor: string;
        };
        AuthProviderTestParams: {
            /**
             * @description The test action to take.
             * @enum {string}
             */
            action?: "connection" | "authentication";
            auth?: components["schemas"]["ProviderAuth"];
            /**
             * Format: int64
             * @description LDAP connection timeout in milliseconds
             */
            timeout?: number;
            /** @description If true, encrypts the connection to LDAP using STARTTLS */
            tls?: boolean;
            /** @description Connection URL to your LDAP server */
            url?: string;
        };
        AuthProviders: components["schemas"]["AuthProvider"][];
        AuthRole: {
            description: string;
            name: string;
            namespace?: string;
            /** @description Rules for access to resources. */
            resourceRules?: components["schemas"]["ResourceRule"][];
            /** @description Rules for access to EDB tables, including via EQL. */
            tableRules?: components["schemas"]["TableRule"][];
            /** @description Rules for access to APIServer routes. */
            urlRules?: components["schemas"]["UrlRule"][];
        };
        AuthRoles: components["schemas"]["AuthRole"][];
        AuthUser: {
            email?: string;
            enabled?: boolean;
            firstName?: string;
            /** @description contains the UUIDs of the groups of which the user is a member. */
            groups?: string[];
            lastName?: string;
            /** Format: int64 */
            maxSessions?: number;
            password?: string;
            status?: components["schemas"]["UserStatus"];
            username?: string;
            uuid?: string;
        };
        AuthUserGroup: {
            description?: string;
            /** @description contains the full user definitions of the users who are members of the group, if requested */
            "full-users"?: components["schemas"]["AuthUser"][];
            /** @description contains the full role definitions of the Roles and ClusterRoles associated with the group, if requested */
            fullRoles?: components["schemas"]["AuthRole"][];
            /** @description if true, indicates that the group was imported from a federated LDAP server */
            isFederated?: boolean;
            name?: string;
            /** @description Contains the names of the ClusterRoles and Roles roles associated with the group.
             *     A Role name has the form "namesspace:rolename", whereas a ClusteRole name is a
             *     simple "rolename", without a colon or a namespace. */
            roles?: string[];
            /** @description contains the usernames of the users who are members of the group */
            users?: string[];
            uuid?: string;
        };
        AuthUserGroups: components["schemas"]["AuthUserGroup"][];
        AuthUsers: components["schemas"]["AuthUser"][];
        CrAnnotation: {
            cr?: components["schemas"]["NsCrGvkName"];
            lines?: components["schemas"]["LineSegment"][];
        };
        /** Credentials (password) for a user. This can never be retrieved from the system. */
        Credentials: {
            /** @description This is true if the password being set is a temporary password.  In this case the user
             *     is required to change the password after they login using the temporary password. */
            temporary?: boolean;
            /** @description The new password for the user. */
            value?: string;
        };
        /** Wrapper for index information inside an error. */
        ErrorIndex: {
            /** Format: int64 */
            index?: number;
        };
        ErrorItem: {
            error?: Record<string, never>;
            type?: string;
        };
        /** @description Generic error response for REST APIs */
        ErrorResponse: {
            /**
             * Format: int64
             * @description the numeric HTTP error code for the response.
             */
            code: number;
            /** @description The optional details of the error response. */
            details?: string;
            /** @description Dictionary/map of associated data/information relevant to the error.
             *     The error "message" may contain {{name}} escapes that should be substituted
             *     with information from this dictionary. */
            dictionary?: {
                [key: string]: unknown;
            };
            /** @description Collection of errors in cases where more than one exists. This needs to be
             *     flexible so we can support multiple formats */
            errors?: components["schemas"]["ErrorItem"][];
            index?: components["schemas"]["ErrorIndex"];
            /**
             * Format: int64
             * @description Internal error code in cases where we don't have an array of errors
             */
            internal?: number;
            /** @description The basic text error message for the error response. */
            message: string;
            /** @description Reference to the error source. Should typically be the URI of the request */
            ref?: string;
            /** @description URI pointing at a document that describes the error and mitigation steps
             *     If there is no document, point to the RFC for the HTTP error code */
            type?: string;
        };
        FlowGetResponse: {
            /** @description If no error is present, the flow completed successfully */
            error?: string;
            /**
             * Format: int64
             * @description The id of the workflow
             */
            id?: number;
            /** @description A JSON representation of the result */
            jsonResult?: string;
            /** @description Log output from the flow */
            log?: string;
            /** @description Name of the workflow */
            name?: string;
            /** @description The namespace in which the flow ran */
            namespace?: string;
            /**
             * Format: int64
             * @description The id of the parent workflow, if any
             */
            parentId?: number;
            /** @description The list of stages of the workflow */
            stages?: components["schemas"]["FlowStage"][];
            /** @enum {string} */
            state?: "waitingToStart" | "running" | "waitingForInput" | "terminated" | "failed" | "completed" | "subflowWaitingForInput";
            /** @description The ids of any subflows that are waiting for user input */
            subflowsWaitingForInput?: number[];
            /** @description The type of workflow */
            type?: string;
            /** @description Set if the state is waiting for input */
            waitForInputPrompt?: string;
        };
        FlowListEntry: {
            /**
             * Format: int64
             * @description The id of the workflow
             */
            id?: number;
            /** @description Name of the workflow */
            name?: string;
            /** @description The namespace in which the workflow ran */
            namespace?: string;
            /**
             * Format: int64
             * @description The id of the parent workflow, if any
             */
            parentId?: number;
            /** @enum {string} */
            state?: "waitingToStart" | "running" | "waitingForInput" | "terminated" | "failed" | "completed" | "subflowWaitingForInput";
            /** @description The type of workflow */
            type?: string;
        };
        /** @description A list of flows */
        FlowListResult: {
            flows?: components["schemas"]["FlowListEntry"][];
        };
        /** @description Describes the stage of a workflow */
        FlowStage: {
            /** @description True if the stage has completed */
            completed?: boolean;
            /** @description True if the stage is complete and there was an error */
            hadError?: boolean;
            /** @description Name of the flow stage */
            name?: string;
            /** @description True if the stage was skipped */
            skipped?: boolean;
            /** @description True if the stage has started */
            started?: boolean;
            /** @description The ids of flows triggered by the stage */
            subFlowIds?: number[];
        };
        GetLabelCompletionRequest: {
            gvk?: components["schemas"]["GroupVersionKind"];
            /**
             * Format: uint32
             * @description The maximum number of results to return
             */
            limit?: number;
            /** @description The namespace of the GVK if the CRD is namespaced
             *     required: true if the GVK is namespaced */
            namespace?: string;
            /** @description A key value string delimited by =.  If the Value does not include an =
             *     it is assumed to be a Key lookup.  If there is an =, everything before
             *     the = is assumed to be the key and the lookup will be a value lookup */
            value: string;
        };
        /** A list of user group identifiers (uuid values). */
        GroupIDs: string[];
        GroupVersionKind: {
            group?: string;
            kind?: string;
            version?: string;
        };
        /** Structure containing a health report for the EDA cluster. */
        Health: {
            /**
             * @description Indication of the activity of this cluster.
             * @enum {string}
             */
            mode: "ACTIVE" | "STANDBY";
            /** @description Detailed health of the services comprising the EDA cluster.  Keyed by the name of the service. */
            services?: {
                [key: string]: components["schemas"]["HealthServiceStatus"];
            };
            /**
             * @description Overall health status of the EDA cluster.
             * @enum {string}
             */
            status: "UP" | "DEGRADED" | "DOWN";
            /**
             * Format: date-time
             * @description Time that the health report was generated.
             */
            timestamp: string;
        };
        /** Structure containing a health report for a particular service. */
        HealthServiceStatus: {
            /** @description Detailed status if the service is not up. */
            error?: string;
            /**
             * @description Health status of the given service.  UP or DOWN.
             * @enum {string}
             */
            status: "UP" | "DOWN";
        };
        K8SPatchOp: {
            from?: string;
            op: string;
            path: string;
            value?: Record<string, never>;
            "x-permissive"?: boolean;
        };
        LabelCompletionResponse: {
            results?: string[];
        };
        LineSegment: {
            /** Format: uint32 */
            endLine?: number;
            /** Format: uint32 */
            startLine?: number;
        };
        Metadata: {
            annotations?: {
                [key: string]: string;
            };
            labels?: {
                [key: string]: string;
            };
            name: string;
            namespace?: string;
        };
        /** @description Information about an individual namespace */
        NamespaceData: {
            /** @description The description of the namespace */
            description?: string;
            /** @description The namespace name */
            name?: string;
        };
        /** @description Body of the non streaming namespace get request */
        NamespaceGetResponse: {
            /** @description If true, the requestor is considered to have permission to access all namespaces */
            allNamesapces?: boolean;
            /** @description The list of namespaces */
            namespaces?: components["schemas"]["NamespaceData"][];
        };
        NodeConfigResponse: {
            /** @description The the list of annotations for the node configuration */
            annotations?: components["schemas"]["CrAnnotation"][];
            /** @description The current node configuration for the node */
            running?: string;
        };
        NsCrGvkName: {
            gvk?: components["schemas"]["GroupVersionKind"];
            name?: string;
            namespace?: string;
        };
        Overlay: {
            endpoint_state?: components["schemas"]["TopoOverlayStateMetadata"][];
            group?: string;
            link_state?: components["schemas"]["TopoOverlayStateMetadata"][];
            name?: string;
            node_badge?: components["schemas"]["TopoOverlayBadgeMetadata"][];
            node_state?: components["schemas"]["TopoOverlayStateMetadata"][];
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            version?: string;
        };
        Overlays: components["schemas"]["Overlay"][];
        Patch: components["schemas"]["K8SPatchOp"][];
        ProviderAuth: {
            /** @description Credentials to use when binding to an LDAP provider */
            bindCredential: string;
            /** @description DN to use when binding to an LDAP provider */
            bindDN: string;
        };
        QueryCompletion: {
            completion?: string;
            token?: string;
        };
        /** @description The result of a successful query auto-completion request */
        QueryCompletionResponse: {
            /** @description Array of possible auto-completion results. */
            completions?: components["schemas"]["QueryCompletion"][];
        };
        /** A role rule controlling access to a kubernetes resource. */
        ResourceRule: {
            /** @description The API groups for the resources controlled by the rule.
             *     An API group consists of an apiGroup and a version, e.g. "apigroup/version".
             *     The API group can be a wildcard ("*"), in which case it will match any API group.
             *     In addition, the version can be a wildcard. */
            apiGroups: string[];
            /**
             * @description Permissions for resources specified by the rule.
             * @enum {string}
             */
            permissions?: "none" | "read" | "readWrite";
            /** @description Names for the resources controlled by the rule.
             *     It can be a wildcard ("*"), in which case it will match any resource
             *     in the matching API groups. */
            resources: string[];
        };
        /** The response body content for a streaming GET request. */
        StreamResult: {
            /** @description The details for the streaming request; e.g. the query string in the corresponding GET request. */
            details?: string;
            /** @description The stream identifier specified in the corresponding streaming GET request. */
            stream?: string;
        };
        /** @description A role rule controlling access to a EDB table.  Note that
         *     there is never write access to EDB. */
        TableRule: {
            /** @description EDB path to which this rule applies. It can end in ".*"
             *     in which case the final portion of the table path can be anything, if the
             *     prefix matches. It can end in ".**" in which case the table path can be
             *     anything if the prefix matches. */
            path: string;
            /**
             * @description Permissions for the given EDB path.
             * @enum {string}
             */
            permissions: "none" | "read";
        };
        TopoAttrMetadata: {
            type?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
        };
        TopoElemMetadata: {
            attributes?: {
                [key: string]: components["schemas"]["TopoAttrMetadata"];
            };
            schema?: components["schemas"]["TopoSchema"];
            subtitle?: string;
            subtitle_key?: string;
        };
        TopoEndpoint: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoGroupingStateRequest: {
            name?: string;
            spec?: components["schemas"]["TopologyStateGroupingBase"];
        };
        TopoLink: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            endpoint_a?: components["schemas"]["TopoLinkEndpoint"];
            endpoint_a_details?: components["schemas"]["TopoEndpoint"];
            endpoint_b?: components["schemas"]["TopoLinkEndpoint"];
            endpoint_b_details?: components["schemas"]["TopoEndpoint"];
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoLinkEndpoint: {
            endpoint?: string;
            node?: string;
            node_key?: string;
        };
        TopoNode: {
            attributes?: {
                [key: string]: Record<string, never>;
            };
            cr_name?: string;
            grouping?: components["schemas"]["TopoNodeGrouping"];
            key?: string;
            labels?: {
                [key: string]: string;
            };
            name?: string;
            namespace?: string;
            schema?: components["schemas"]["TopoSchema"];
            ui_name?: string;
        };
        TopoNodeGrouping: {
            group?: string;
            /** Format: int64 */
            tier?: number;
        };
        TopoOverlayBadgeMetadata: {
            badge_name?: string;
            badge_path?: string;
            color?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            /** Format: int64 */
            value?: number;
        };
        TopoOverlayStateMetadata: {
            color?: string;
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            /** Format: int64 */
            value?: number;
        };
        TopoOverlayStateRequest: {
            badge?: string;
            status?: string;
        };
        TopoSchema: {
            group?: string;
            kind?: string;
            version?: string;
        };
        TopoStateRequest: {
            grouping?: components["schemas"]["TopoGroupingStateRequest"];
            namespace?: string;
            overlays?: components["schemas"]["TopoOverlayStateRequest"];
        };
        Topologies: components["schemas"]["Topology"][];
        Topology: {
            endpoints?: components["schemas"]["TopoElemMetadata"];
            group?: string;
            grouping?: components["schemas"]["TopoSchema"];
            links?: components["schemas"]["TopoElemMetadata"];
            name?: string;
            nodes?: components["schemas"]["TopoElemMetadata"];
            ui_description?: string;
            ui_description_key?: string;
            ui_name?: string;
            ui_name_key?: string;
            version?: string;
        };
        TopologyState: {
            links?: {
                [key: string]: components["schemas"]["TopoLink"];
            };
            nodes?: {
                [key: string]: components["schemas"]["TopoNode"];
            };
        };
        TopologyStateGroupSelector: {
            /** @description The group to assign to nodes that match the selector.
             *     +eda:ui:title="Group" */
            group?: string;
            /** @description +kubebuilder:validation:Optional
             *     +eda:ui:title="Node Selector"
             *     +eda:ui:format="labelselector"
             *     Label selector to use to match nodes that should be assigned to this group. */
            nodeSelector?: string[];
        };
        /** @description Embed this type inside your topology tier CRD spec to determine the tiers and the
         *     groups of the nodes in the topology. */
        TopologyStateGroupingBase: {
            /** @description The set of selectors for assigning nodes to groups
             *     +eda:ui:title="Group Selectors" */
            groupSelectors?: components["schemas"]["TopologyStateGroupSelector"][];
            /** @description The set of selectors for assigning nodes to tiers
             *     +eda:ui:title="Tier Selectors" */
            tierSelectors?: components["schemas"]["TopologyStateTierSelector"][];
            /** @description A description of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Description" */
            uiDescription?: string;
            /** @description The translation key for the description of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Description Key" */
            uiDescriptionKey?: string;
            /** @description The name of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Name" */
            uiName?: string;
            /** @description The translation key for the name of the topology grouping to expose in the UI
             *     +eda:ui:title="UI Name Key" */
            uiNameKey?: string;
        };
        TopologyStateTierSelector: {
            /** @description +kubebuilder:validation:Optional
             *     +eda:ui:title="Node Selector"
             *     +eda:ui:format="labelselector"
             *     Label selector to use to match nodes that should be assigned to this tier. */
            nodeSelector?: string[];
            /**
             * Format: uint32
             * @description The tier to assign to nodes that match the selector.
             *     +eda:ui:title="Tier"
             */
            tier?: number;
        };
        /** Request body content for a POST transaction request. */
        Transaction: {
            /** @description List of CRs to include in the transaction */
            crs: components["schemas"]["TransactionCr"][];
            /** @description Description/commit message for the transaction */
            description: string;
            /** @description If true the transaction will not be committed and will run in dry run mode.  If false the
             *     transaction will be committed */
            dryRun: boolean;
            /** @description The type of result - errors only, normal, or debug */
            resultType?: string;
            /** @description retain after results fetched - e.g. after call to get transaction result */
            retain?: boolean;
        };
        TransactionAppError: {
            rawError?: string;
            structuredError?: components["schemas"]["TransactionStructuredAppError"];
        };
        TransactionContent: {
            apiVersion?: string;
            kind?: string;
            metadata?: components["schemas"]["Metadata"];
            spec?: Record<string, never>;
        };
        TransactionCr: {
            type?: components["schemas"]["TransactionType"];
        };
        TransactionDetails: {
            /** @description List of changed CRs as part of the transaction */
            changedCrs?: components["schemas"]["TransactionNsCrGvkNames"][];
            /** @description True if the transaction was not committed */
            dryRun?: boolean;
            /** @description List of general errors while running the transaction */
            generalErrors?: string[];
            /** @description List of input CRs from the transaction */
            inputCrs?: components["schemas"]["TransactionInputResource"][];
            /** @description List of intents which ran as part of the transaction */
            intentsRun?: components["schemas"]["TransactionIntentResult"][];
            /** @description List of nodes with configuration changes from the transaction */
            nodesWithConfigChanges?: components["schemas"]["TransactionNodeResult"][];
            /** @description The state of the transaction */
            state?: string;
            /** @description True if the CR was successfully applied */
            success?: boolean;
        };
        TransactionExecutionResult: {
            /** @description List of changed CRs as part of the transaction */
            changedCrs?: components["schemas"]["TransactionNsCrGvkNames"][];
            /** @description Information about time taken during processing */
            executionSummary?: string;
            /** @description List of general errors while running the transaction */
            generalErrors?: string[];
            /** @description List of intents which ran as part of the transaction */
            intentsRun?: components["schemas"]["TransactionIntentResult"][];
            /** @description List of nodes with configuration changes from the transaction */
            nodesWithConfigChanges?: components["schemas"]["TransactionNodeResult"][];
        };
        TransactionId: {
            /**
             * Format: uint64
             * @description A transaction identifier; these are assigned by the system to a posted transaction.
             */
            id?: number;
        };
        TransactionInputResource: {
            isDelete?: boolean;
            name?: components["schemas"]["NsCrGvkName"];
        };
        TransactionIntentResult: {
            errors?: components["schemas"]["TransactionAppError"][];
            intentName?: components["schemas"]["NsCrGvkName"];
            outputCrs?: components["schemas"]["NsCrGvkName"][];
            poolAllocation?: components["schemas"]["TransactionPoolAllocation"][];
            script?: components["schemas"]["TransactionScriptResults"];
        };
        /** @description The name of a node with changes from a transaction, and a list
         *     of errors that occurred for the node */
        TransactionNodeResult: {
            /** @description Resulting errors for the node */
            errors?: string[];
            /** @description The name of the node */
            name?: string;
            /** @description The namespace of the node */
            namespace?: string;
        };
        TransactionNsCrGvkNames: {
            gvk?: components["schemas"]["GroupVersionKind"];
            names?: string[];
            namespace?: string;
        };
        TransactionPatch: {
            patchOps: components["schemas"]["Patch"];
            target: components["schemas"]["NsCrGvkName"];
        };
        TransactionPoolAllocation: {
            key?: string;
            poolName?: string;
            poolTemplate?: string;
            value?: string;
        };
        TransactionResultInputResources: {
            /** @description List of input resources from the transaction */
            inputCrs?: components["schemas"]["TransactionInputResource"][];
            /** @description This field is true if the list returned here is not the complete list of input resources in the transaction because the user does not have read-access to some of them */
            limitedAccess?: boolean;
        };
        TransactionResultObject: {
            after?: components["schemas"]["TransactionResultObjectString"];
            before?: components["schemas"]["TransactionResultObjectString"];
            /** @description True if there is no data available for the result */
            dataUnavailable?: boolean;
            /** @description The format of the response - Text or YAML */
            format?: string;
        };
        TransactionResultObjectString: {
            data?: string;
        };
        TransactionScriptResults: {
            /** Format: uint32 */
            executionTime?: number;
            output?: string;
        };
        TransactionState: {
            /** @description The state of the transaction */
            state?: string;
        };
        TransactionStructuredAppError: {
            message?: string;
            messageKey?: string;
            values?: {
                [key: string]: Record<string, never>;
            };
        };
        /** @description Summary of the result of a transaction */
        TransactionSummaryResult: {
            /** @description The git commit hash for the transaction */
            commitHash?: string;
            /** @description The description of the transaction, as posted in the transaction request. */
            description?: string;
            /** @description The type of details available for the transaction, as posted in the transaction request. */
            details?: string;
            /** @description If true the transaction was not committed and ran in dry run mode. */
            dryRun?: boolean;
            /**
             * Format: uint64
             * @description The transaction identifier
             */
            id?: number;
            /** @description The time that the transaction completed. */
            lastChangeTimestamp?: string;
            /** @description The state of the transaction. */
            state?: string;
            /** @description True if the transaction was successful. */
            success?: boolean;
            /** @description The user who posted the transaction. */
            username?: string;
        };
        TransactionSummaryResults: {
            /** @description array of summary-results for transactions */
            results?: components["schemas"]["TransactionSummaryResult"][];
        };
        TransactionType: {
            create?: components["schemas"]["TransactionValue"];
            delete?: components["schemas"]["NsCrGvkName"];
            modify?: components["schemas"]["TransactionValue"];
            patch?: components["schemas"]["TransactionPatch"];
            replace?: components["schemas"]["TransactionValue"];
        };
        TransactionValue: {
            value?: components["schemas"]["TransactionContent"];
        };
        /** A role rule controlling access to an API server endpoint/route. */
        UrlRule: {
            /** @description The API server URL path to which this rule applies. It can end in "/*"
             *     in which case the final portion of the URL path can be anything, if the
             *     prefix matches. It can end in "/**" in which case the URL path can be
             *     anything if the prefix matches.", */
            path: string;
            /**
             * @description The permissions for the API server URL for the rule.
             * @enum {string}
             */
            permissions?: "none" | "read" | "readWrite";
        };
        UserStatus: {
            /** Format: int64 */
            failedLoginSinceSuccessfulLogin?: number;
            /** @description True if the user comes from a federated LDAP server */
            isFederatedUser?: boolean;
            lastFailedLogin?: string;
            lastSuccessfulLogin?: string;
            temporarilyDisabled?: boolean;
        };
        /** request body contents for a PUT/POST file user-storage request. */
        UserStorageInFileContent: {
            /** @description The desired content of the user-storage file. This will be base64 decoded before storing if the request indicates that the content is base64 encoded. */
            "file-content": string;
        };
        /** The data returned to the client from a GET directory user-storage request. */
        UserStorageOutDirContent: {
            /** @description path for the directory within the users storage */
            "directory-path": string;
            /** @description array of entries for the items in the directory */
            entries: components["schemas"]["UserStorageOutDirEntry"][];
        };
        /** @description user-storage directory entry */
        UserStorageOutDirEntry: {
            /**
             * Format: date-time
             * @description modification type of the item, if a file
             */
            "modification-time"?: string;
            /** @description name of the item within the directory */
            name: string;
            /** @description type of the item; "file" or "directory" */
            type: string;
        };
        UserStorageOutFileContent: {
            /** @description content of the file, will be base64 encoded if the request asked for this */
            "file-content"?: string;
            /** @description if present and true, indicates the file has been deleted; used for
             *     streamed responses */
            "file-deleted"?: boolean;
            /** @description name of the file */
            "file-name": string;
            /**
             * Format: date-time
             * @description UTC modification time of the file, as an RFC 3339 date/time.
             *     Not valid if file-deleted is true (in a streamed response)
             */
            "modification-time"?: string;
        };
        Workflow: {
            /** @description Custom resource that defines the workflow to execute */
            cr: {
                [key: string]: Record<string, never>;
            };
            /** @description Description message for the workflow */
            description: string;
        };
        WorkflowId: {
            /**
             * Format: uint64
             * @description A workflow identifier; these are assigned by the system to a posted workflow.
             */
            id?: number;
        };
        WorkflowResult: {
            errorMessage?: string;
            resultMessage?: string;
            state?: components["schemas"]["WorkflowState"];
            success?: boolean;
        };
        WorkflowState: {
            runningState?: string;
            state?: string;
        };
        /** Version information for a single component. */
        singleVersionInfo: {
            /** @description The build-time for the component. */
            builtDate?: string;
            /** @description The version string for the component. */
            version?: string;
        };
        /** Version information for subsystems and the overall EDA product. */
        versionInfo: {
            [key: string]: components["schemas"]["singleVersionInfo"];
        };
        /** @description If present, bind to LDAP server with the given credentials.  Otherwise do not bind. */
        AuthProvider_auth: {
            /** @description Credentials to use when binding to an LDAP provider */
            bindCredential: string;
            /** @description DN to use when binding to an LDAP provider */
            bindDN: string;
        };
        /** @description Configuration for group import/sync with LDAP.  If not present, groups will not synchronized with EDA. */
        AuthProvider_groupSupport: {
            /** @description The LDAP group name attribute */
            NameLDAPAttribute: string;
            /** @description Further for filtering when retrieving LDAP groups. Ensure starts and ends with parentheses if using. */
            filter?: string;
            /** @description The LDAP DN where groups are found. */
            groupLDAPDN: string;
            /** @description The group attribute for a members.  Usually "member" or "memberUid". */
            memberAttribute?: string;
            /** @description If retrievalStrategy is "memberOf", this is the LDAP user attribute for group memberships. */
            memberOfAttribute?: string;
            /**
             * @description How users are identified in a group member entry: either DN or UID.
             * @enum {string}
             */
            membershipAttributeType?: "DN" | "UID";
            /** @description Only required if membershipAttributeType is UID; then it is the user attribute that should match the group member value. */
            membershipUserAttribute?: string;
            /** @description The LDAP object class or classes used for groups. If more than one, they must be comma-separated. */
            objectClasses: string;
            /**
             * @description The strategy for retrieving groups.  Should be "member" to get group membership from the group, or "memberOf" to get group membership from the user.
             * @enum {string}
             */
            retrievalStrategy?: "member" | "memberOf";
        };
    };
    responses: never;
    parameters: never;
    requestBodies: never;
    headers: never;
    pathItems: never;
}
export type $defs = Record<string, never>;
export interface operations {
    activityGet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description Response when cluster is active. There is no body. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Response when cluster is standby. There is no body. */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Response for errors. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    healthGet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a GET health request when fully healthy. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Health"];
                };
            };
            /** @description The response for a GET health request when degraded. */
            500: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Health"];
                };
            };
            /** @description The response for a GET health request when non-healthy. */
            503: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Health"];
                };
            };
        };
    };
    versionGet: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET version request.
             *     A map of version information for various components,
             *     including an overall version for the "eda" component. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["versionInfo"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    accessGetNamespaces: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET namespaces request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NamespaceGetResponse"];
                };
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetProviders: {
        parameters: {
            query?: {
                /** @description The result will be limited to providers whose name is this parameter. */
                name?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The EDA federation providers. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProviders"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateProvider: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition the EDA provider to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthProvider"];
            };
        };
        responses: {
            /** @description The definition of the newly created EDA federation provider. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProvider"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetProvider: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA provider whose definition should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The definition of the specified EDA federation provider. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProvider"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateProvider: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA provider whose definition should be updated. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The definition the EDA provider to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthProvider"];
            };
        };
        responses: {
            /** @description The new definition of the EDA federation provider. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthProvider"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteProvider: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA provider to be deleted. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminTestProvider: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition of the test parameters */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthProviderTestParams"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUserGroups: {
        parameters: {
            query?: {
                /** @description If true, the full definitions of the roles associated with the group
                 *     are returned, rather than just the role names. */
                "full-roles"?: boolean;
                /** @description If true, the full definitions of the users which are members of the group
                 *     are returned, rather than just the user names. */
                "full-users"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The resulting set of EDA user-groups. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroups"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition for the user group to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUserGroup"];
            };
        };
        responses: {
            /** @description The resulting user-group definition. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroup"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUserGroup: {
        parameters: {
            query?: {
                /** @description If true, the full definitions of the roles associated with the group
                 *     are returned, rather than just the role names. */
                "full-roles"?: boolean;
                /** @description If true, the full definitions of the users which are members of the group
                 *     are returned, rather than just the user names. */
                "full-users"?: boolean;
            };
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose definition should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The group definition for the requested EDA user group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroup"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group which should be updated.. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The new definition for the user group. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUserGroup"];
            };
        };
        responses: {
            /** @description The new definition for the EDA user group. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUserGroup"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group which should be deleted. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetRolesOfUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The resulting set of EDA roles. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRoles"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminSetRolesOfUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of role names to be added-to/set-on/removed-from the EDA user group. */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminAddRolesToUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of role names to be added-to/set-on/removed-from the EDA user group. */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminRemoveRolesFromUserGroup: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID of the EDA user group whose roles should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of role names to be added-to/set-on/removed-from the EDA user group. */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetRoles: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description namespace whose roles should be retrieved */
                namespace: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested set of EDA users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRoles"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace in which to create the role */
                namespace: string;
            };
            cookie?: never;
        };
        /** @description The definition of the EDA role to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The resulting role definition. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetRole: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The namespace from which to retrieve the role. */
                namespace: string;
                /** @description The name of the EDA role whose definition should be retrieved/streamed. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role definition for the specified role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace in which the role resides */
                namespace: string;
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        /** @description The new definition of the EDA role. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The updated role definition. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace from which to delete the role */
                namespace: string;
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetPasswordPolicy: {
        parameters: {
            query?: {
                /** @description if set to true, the default password policy definition is returned, rather than the current password policy. */
                "get-default"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The current EDA password policy parameters. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthPasswordPolicy"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdatePasswordPolicy: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The new password policy parameters. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthPasswordPolicy"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetClusterRoles: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested set of EDA users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRoles"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateClusterRole: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The definition of the EDA role to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The resulting role definition. */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetClusterRole: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the EDA role whose definition should be retrieved/streamed. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The role definition for the specified role. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminUpdateClusterRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        /** @description The new definition of the EDA role. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthRole"];
            };
        };
        responses: {
            /** @description The updated role definition. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthRole"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteClusterRole: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the EDA role whose definition should be updated. */
                name: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUsers: {
        parameters: {
            query?: {
                /** @description username of the user whose user record should be retrieved. */
                username?: string;
                /** @description email address of the user whose user record should be retrieved. */
                email?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The requested set of EDA users */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUsers"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminCreateUser: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The attributes of the user to be created. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUser"];
            };
        };
        responses: {
            /** @description The resulting user, includes the uuid assigned to the new user */
            201: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUser"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminGetUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose user record should be retrieved. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The information about the EDA user identified the the uuid */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUser"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminModifyUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose user record should be replaced. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The new attributes for the user. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AuthUser"];
            };
        };
        responses: {
            /** @description The new attributes of the updated user. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AuthUser"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminDeleteUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose user record should be deleted. */
                uuid: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminExecuteEmailActions: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user for which the email actions should be applied. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The list of email actions to execute.  Each action is a single string.
         *     Currently the only supported action is the UPDATE_PASSWORD action, which results
         *     in an email being sent to the user requiring them to update their password via
         *     an embedded link. */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminSetGroupsOfUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose group memberships should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of group identifiers (uuid values) applied during the operation. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupIDs"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminAddGroupsToUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose group memberships should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of group identifiers (uuid values) applied during the operation. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupIDs"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminRemoveGroupsFromUser: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose group memberships should be modified. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The set of group identifiers (uuid values) applied during the operation. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GroupIDs"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    adminSetUserPassword: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The UUID or userid of the user whose password should be set. */
                uuid: string;
            };
            cookie?: never;
        };
        /** @description The new credentials for the user. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Credentials"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetAlarms: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarms request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutAlarms: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The namespace/name of the alarms on which the action should be taken. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteAlarms: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The names of the alarms to be deleted. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetAlarm: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the alarm to retrieve */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET single alarm request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutAlarm: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path: {
                /** @description The name of the alarm on which the action is taken. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteAlarm: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The name of the alarm to delete. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetAlarmHistory: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description name of the alarm whose history should be retrieved. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarm history request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmHistoryData"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetNamespaceAlarmHistory: {
        parameters: {
            query?: {
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description the name of the namespace for the alarm */
                nsName: string;
                /** @description name of the alarm whose history should be retrieved. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarm history request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmHistoryData"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetNamespaceAlarms: {
        parameters: {
            query?: {
                /** @description requests all alarms; the default is to filter-out suppressed alarms.
                 *     Value must be "true" to get all alarms. */
                all?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The namespace to fetch the alarms from */
                nsName: boolean;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET alarms request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"][];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutNamespaceAlarms: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path: {
                /** @description The namespace in which to perform the actions. */
                nsName: string;
            };
            cookie?: never;
        };
        /** @description The namespace/name of the alarms on which the action should be taken. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteNamespaceAlarms: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace in which to delete alarms. */
                nsName: string;
            };
            cookie?: never;
        };
        /** @description The names of the alarms to be deleted. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["AlarmNamespaceAndName"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Any failures will be returned as error-items in the resulting body:ErrorResponse. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmGetNamespaceAlarm: {
        parameters: {
            query?: {
                /** @description requests all alarms; the default is to filter-out suppressed alarms.
                 *     Value must be "true" to get all alarms. */
                all?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The namespace to fetch the alarm from */
                nsName: boolean;
                /** @description The name of the alarm to retrieve */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful non-streaming GET single alarm request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["AlarmData"];
                };
            };
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmPutNamespaceAlarm: {
        parameters: {
            query: {
                /** @description Type of action to take for the alarm. */
                action: "acknowledge" | "unacknowledge" | "suppress" | "unsuppress";
                /** @description The duration (in milliseconds) for the specified acknowledge or suppress action. */
                duration?: number;
            };
            header?: never;
            path: {
                /** @description The namespace of the alarm on which the action is taken. */
                nsName: string;
                /** @description The name of the alarm on which the action is taken. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    alarmDeleteNamespaceAlarm: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace of the alarm to delete. */
                nsName: string;
                /** @description The name of the alarm to delete. */
                "alarm-name": string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description ErrorResponse */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetAllDetails: {
        parameters: {
            query?: {
                /** @description Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state. */
                waitForComplete?: string;
                /** @description Flag to tell the request to fail if the transaction has errors.  By default it will not fail. */
                failOnErrors?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose details are being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-details request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionDetails"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetAllDiffs: {
        parameters: {
            query: {
                /** @description Group information for the configuration record diffs being requested */
                group: string;
                /** @description Version information for the configuration record diffs being requested.  Group is
                 *     required if nodeCfg is not provided */
                version: string;
                /** @description kind information for the configuration record diffs being requested.  Version is
                 *     required if nodeCfg is not provided */
                kind: string;
                /** @description Name information for the configuration record diffs being requested.  Name is required
                 *     if nodeCfg is not provided */
                name: string;
                /** @description Name of the node for the configuration diff being requested */
                nodeCfg?: string;
                /** @description Namespace information for the configuration record diffs being requested.  Namespace is
                 *     required */
                namespace: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose configuration record diffs are being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-diffs request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultObject"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetAllSummaryResult: {
        parameters: {
            query?: {
                /** @description Maximum number of transaction results to return */
                size?: number;
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-summary-list request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionSummaryResults"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetAllState: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose state is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-state request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionState"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    toolsGetLabelCompletions: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The type of label completion - key, value, or gvks */
        requestBody: {
            content: {
                "application/json": components["schemas"]["GetLabelCompletionRequest"];
            };
        };
        responses: {
            /** @description The response for a successful POST label completion request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["LabelCompletionResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    toolsGetNodeConfig: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace of the node whose config are being requested */
                nsName: string;
                /** @description The name of the node whose config are being requested */
                nodeName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET node config request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["NodeConfigResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetQuery: {
        parameters: {
            query: {
                /** @description the information being queried, in the EDA query language */
                query: string;
                /** @description the comma-separated list of namespaces against which the query should be executed */
                namespaces?: string;
                /** @description client information for streaming request */
                eventclient: string;
                /** @description stream information for streaming request */
                stream: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a streaming GET request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetEqlQuery: {
        parameters: {
            query: {
                /** @description the information being queried, in the EDA query language */
                query: string;
                /** @description the comma-separated list of namespaces against which the query should be executed */
                namespaces?: string;
                /** @description client information for streaming request */
                eventclient: string;
                /** @description stream information for streaming request */
                stream: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a streaming GET request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetEqlQueryAutoComplete: {
        parameters: {
            query: {
                /** @description the EDA query language request string */
                query: string;
                /** @description limit on the number of auto-completion results returned by the request */
                completion_limit?: number;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful query auto-completion GET request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["QueryCompletionResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    queryGetNqlQuery: {
        parameters: {
            query: {
                /** @description the information being queried, in the natural query language */
                query: string;
                /** @description the comma-separated list of namespaces against which the query should be executed */
                namespaces?: string;
                /** @description client information for streaming request */
                eventclient: string;
                /** @description stream information for streaming request */
                stream: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a streaming GET request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["StreamResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    topologies: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Topologies"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    topology: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology to retrieve */
                topologyName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Topology"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    overlays: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology on which to list overlays */
                topologyName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Overlays"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    overlay: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology to that owns this overlay */
                topologyName: string;
                /** @description The name of the overlay to retrieve */
                overlayName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["Overlay"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    topologyPostState: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The name of the topology from which to get the state */
                topologyName: string;
            };
            cookie?: never;
        };
        /** @description The options to specify the namespace, grouping and overlays for the topology. */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TopoStateRequest"];
            };
        };
        responses: {
            /** @description OK */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TopologyState"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transPostTransactionV1: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful POST transaction request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetDetails: {
        parameters: {
            query?: {
                /** @description Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state. */
                waitForComplete?: string;
                /** @description Flag to tell the request to fail if the transaction has errors.  By default it will not fail. */
                failOnErrors?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose details are being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-details request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionDetails"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetDiffs: {
        parameters: {
            query: {
                /** @description Group information for the configuration record diffs being requested */
                group: string;
                /** @description Version information for the configuration record diffs being requested.  Group is
                 *     required if nodeCfg is not provided */
                version: string;
                /** @description kind information for the configuration record diffs being requested.  Version is
                 *     required if nodeCfg is not provided */
                kind: string;
                /** @description Name information for the configuration record diffs being requested.  Name is required
                 *     if nodeCfg is not provided */
                name: string;
                /** @description Name of the node for the configuration diff being requested */
                nodeCfg?: string;
                /** @description Namespace information for the configuration record diffs being requested.  Namespace is
                 *     required */
                namespace: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose configuration record diffs are being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-diffs request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultObject"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transRestoreTransactionV1: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction being reverted or restored. */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The identifier for the transaction ID used to restore to the state of the specified transaction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetSummaryResultV1: {
        parameters: {
            query?: {
                /** @description Maximum number of transaction results to return */
                size?: number;
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-summary-list request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionSummaryResults"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transRevertTransactionV1: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction being reverted or restored. */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The identifier for the transaction ID used to revert the transaction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetStateForUser: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose state is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-state request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionState"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transPostTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Details of the transaction */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Transaction"];
            };
        };
        responses: {
            /** @description The response for a successful POST transaction request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transRestoreTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction being reverted or restored. */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The identifier for the transaction ID used to restore to the state of the specified transaction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetNodeConfigDiff: {
        parameters: {
            query: {
                /** @description Name of the node for the configuration diff being requested */
                node: string;
                /** @description Namespace of the node for the configuration diff being requested. */
                namespace: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose resource diff is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-diffs request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultObject"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetResourceDiff: {
        parameters: {
            query: {
                /** @description Group information for the resource diff being requested.  Group is required but can be empty for non-EDA resources */
                group: string;
                /** @description Version information for the resource diff being requested.  Version is required */
                version: string;
                /** @description kind information for the resource diff being requested.  Kind is required */
                kind: string;
                /** @description Name information for the resource diff being requested.  Name is required */
                name: string;
                /** @description Namespace information for the resource diff being requested.  Namespace is
                 *     required if the resource is namespaced or is a non-EDA resource */
                namespace: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose resource diff is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-diffs request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultObject"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetResultExecution: {
        parameters: {
            query?: {
                /** @description Flag for the request to wait until the transaction is complete before returning.  By default it returns the current state. */
                waitForComplete?: string;
                /** @description Flag to tell the request to fail if the transaction has errors.  By default it will not fail. */
                failOnErrors?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose details are being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-execution request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionExecutionResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetResultInputResources: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction whose list of input resources is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-inputresources request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionResultInputResources"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetSummaryResultList: {
        parameters: {
            query: {
                /** @description Maximum number of transaction results to return */
                size: number;
                /** @description When provided, the liast of transactions is limited to those initiated by the specified user. */
                username?: string;
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-summary-list request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionSummaryResults"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetSummaryResult: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction whose state is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-result-summary request.
             *     This request returns the summary for a single, specified transaction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionSummaryResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transRevertTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The identifier for the transaction being reverted or restored. */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The identifier for the transaction ID used to revert the transaction. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transGetState: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the transaction whose state is being requested */
                transactionId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET transaction-state request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["TransactionState"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    transValidateTransaction: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description The CR to validate */
        requestBody: {
            content: {
                "application/json": components["schemas"]["TransactionCr"][];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET directory user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutDirContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET file user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutFileContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPutFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPostFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteFiles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description paths for the files being deleted */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetSharedDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET directory user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutDirContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteSharedDirectory: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussGetSharedFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
                /** @description if true, file content will be base64-encoded before being returned */
                "base64-encode"?: boolean;
                /** @description client information for streaming request */
                eventclient?: string;
                /** @description stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET file user-storage request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["UserStorageOutFileContent"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPutSharedFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussPostSharedFile: {
        parameters: {
            query: {
                /** @description path for the file whose contents should be written */
                path: string;
                /** @description true if the content was base64-encoded before being sent. */
                "base64-encoded"?: boolean;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description content for the file */
        requestBody: {
            content: {
                "application/json": components["schemas"]["UserStorageInFileContent"];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteSharedFile: {
        parameters: {
            query: {
                /** @description path for the file/directory being manipulated */
                path: string;
            };
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    ussDeleteSharedFiles: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description paths for the files being deleted */
        requestBody: {
            content: {
                "application/json": string[];
            };
        };
        responses: {
            /** @description no data is returned for this response type. */
            204: {
                headers: {
                    [name: string]: unknown;
                };
                content?: never;
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    workflowPostWorkflow: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        /** @description Details of the workflow */
        requestBody: {
            content: {
                "application/json": components["schemas"]["Workflow"];
            };
        };
        responses: {
            /** @description The response for a successful POST workflow request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowId"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getNamespaceWorkflowList: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The namespace for the requested workflow list */
                nsName: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET flowlist request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FlowListResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    workflowGetDetails: {
        parameters: {
            query?: {
                /** @description Flag for the request to wait until the workflow is complete before returning */
                waitForComplete?: string;
                /** @description Flag to tell the request to fail if the workflow has errors */
                failOnErrors?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the workflow whose details is being requested */
                workflowId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET workflow-detail request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getWorkflowList: {
        parameters: {
            query?: never;
            header?: never;
            path?: never;
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET flowlist request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FlowListResult"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    workflowGetState: {
        parameters: {
            query?: {
                /** @description Client information for streaming request */
                eventclient?: string;
                /** @description Stream information for streaming request */
                stream?: string;
            };
            header?: never;
            path: {
                /** @description The identifier for the workflow whose state is being requested */
                workflowId: number;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET workflow-state request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["WorkflowState"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
    getWorkflow: {
        parameters: {
            query?: never;
            header?: never;
            path: {
                /** @description The id for the requested workflow */
                workflowId: string;
            };
            cookie?: never;
        };
        requestBody?: never;
        responses: {
            /** @description The response for a successful GET workflow request. */
            200: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["FlowGetResponse"];
                };
            };
            /** @description Details of an error in response to an API REST request. */
            default: {
                headers: {
                    [name: string]: unknown;
                };
                content: {
                    "application/json": components["schemas"]["ErrorResponse"];
                };
            };
        };
    };
}
